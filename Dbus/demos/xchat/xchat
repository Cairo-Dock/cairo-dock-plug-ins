#!/usr/bin/python

# This is a part of the external demo applet for Cairo-Dock
#
# Copyright : (C) 2010 by Fabounet
# E-mail : fabounet@users.berlios.de
#
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# http://www.gnu.org/licenses/licenses.html#GPL

####################
### dependancies ###
####################
import sys
import os.path
import subprocess
import ConfigParser
import gobject
import glib
import dbus
from dbus.mainloop.glib import DBusGMainLoop

##################################
### get our applet on the bus ###
##################################
applet_name = os.path.basename(os.path.abspath("."))  # the name of the applet must the same as the folder.
applet_path = "/org/cairodock/CairoDock/"+applet_name  # path where our object is stored on the bus.
DBusGMainLoop(set_as_default=True)
bus = dbus.SessionBus()
try:
	applet_object = bus.get_object("org.cairodock.CairoDock", applet_path)
except dbus.DBusException:
	print ">>> module '"+applet_name+"' can't be found on the bus, exit."
	sys.exit(2)
myIcon = dbus.Interface(applet_object, "org.cairodock.CairoDock.applet")  # this object represents our applet and also our icon inside the dock or a desklet.

##################################
### callbacks on the main icon ###
##################################
def _try_connect():
	myApplet.connect_to_xchat()
	if myApplet.xchat == None:  # toujours pas connecte.
		myApplet.iNbTries += 1
		if myApplet.iNbTries == 5:  # au bout de 5 essais on abandonne.
			myApplet.icon.ShowDialog("Couldn't connect to xchat :-(",4)
			myApplet.iSidConnect = 0
			return False
		return True
	else:  # connexion etablie.
		myApplet.iSidConnect = 0
		return False
def action_on_click(iState):
	print ">>>>> clic !"
	if myApplet.xchat == None:  # pas connecte
		if myApplet.iSidConnect == 0:  # et pas en train de le faire
			subprocess.Popen("xchat")
			myApplet.iNbTries = 0
			myApplet.iSidConnect = gobject.timeout_add(1000,_try_connect)
		else:  # en cours de connexion
			myApplet.icon.ShowDialog("Connecting to xchat, please wait ...",4)
	else:  # on montre la fenetre.
		try:
			myApplet.xchat.Command("GUI SHOW")
		except dbus.DBusException:
			print "xhat has quitted without telling us !"
			myApplet.xchat = None
			myApplet.connect_to_xchat()
			if myApplet.xchat == None:
				print "seems xchat is not running"
				subprocess.Popen("xchat")
				myApplet.iNbTries = 0
				myApplet.iSidConnect = gobject.timeout_add(1000,_try_connect)
			else:
				myApplet.xchat.Command("GUI SHOW")

def action_on_middle_click():
	print ">>> middle clic !"
	if myApplet.xchat == None:
		return	
	ctx = myApplet.xchat.FindContext ('', '')  # NULL,NULL => the currently focused tab/window will be returned.
	myApplet.xchat.SetContext(ctx)  # on se place sur le canal courant dans la fenetre.
	myApplet.icon.AskText("Send a message on "+myApplet.xchat.GetInfo("channel"), "");

def action_on_build_menu():
	print ">>> build menu !"
	if myApplet.xchat == None:
		return
	chans = myApplet.list_channels()
	myApplet.icon.PopulateMenu(chans)

def action_on_menu_select(iNumEntry):
	chans = myApplet.list_channels()
	print ">>> channel" + chans[iNumEntry]
	channel=''
	channel=chans[iNumEntry]
	ctx = myApplet.xchat.FindContext('', channel)
	if ctx == 0:
		return
	myApplet.xchat.SetContext(ctx)
	myApplet.xchat.Command("GUI FOCUS")
	myApplet.xchat.Command("GUI SHOW")

def action_on_scroll(bDirectionUp):
	print ">>> scroll",bDirectionUp,myApplet.iNbMsg
	if myApplet.iNbMsg != 0 :
		if bDirectionUp:
			myApplet.iCurrentMsg += 1
		else:
			myApplet.iCurrentMsg -= 1
		if myApplet.iCurrentMsg > myApplet.iNbMsg:
			myApplet.iCurrentMsg = myApplet.iNbMsg
		elif myApplet.iCurrentMsg < 0:
			myApplet.iCurrentMsg = 0
		myApplet.icon.ShowDialog(myApplet.pMsgList[myApplet.iCurrentMsg], 10)
	
def action_on_answer(answer):
	print ">>> answer :",answer
	if answer == None or answer == '':
		return
	myApplet.xchat.Command("say "+answer);

def action_on_change_focus(has_focus):
	myApplet.bHasFocus = has_focus
	print ">>>>>>> xid : ",myApplet.icon.Get("Xid")
	if has_focus:
		print ">>> got focus"
		if myApplet.bHasUnread and myApplet.config['msg animation'] != '':
			print ">>> stop animation"
			myApplet.icon.Animate('',0)
		myApplet.bHasUnread = False
		myApplet.iCurrentMsg = 0

###############################
### callbacks on the applet ###
###############################
def action_on_stop():
	print ">>> our module is stopped"
	myApplet.disconnect_from_xchat()
	loop.quit()

def action_on_reload(bConfigHasChanged):
	print ">>> our module is reloaded"
	if bConfigHasChanged:
		print ">>>  and our config has changed"
		myApplet.get_config()

#########################
### Events from xchat ###
#########################
def action_on_command_catched(words, words_eol, hook_id, ctx_id):
	if myApplet.HookCmdId != hook_id:
		return
	print ">>> CMD :" + words_eol[1]
	myApplet.icon.ShowDialog("Yes, Master ?",4)

def action_on_server_event(words, words_eol, hook_id, ctx_id):
	if myApplet.HookServerId != hook_id:
		return
	print ">>> EVENT :" + words_eol[1]
	if myApplet.config['channel message']:
		if myApplet.config['duration'] == 0:
			coef = 20
		elif myApplet.config['duration'] == 1:
			coef = 10
		else:
			coef = 5
		myApplet.icon.ShowDialog(words_eol[1],max(1,len(words_eol[1])/coef))
	if myApplet.config['msg animation'] != '':
		myApplet.icon.Animate(myApplet.config['msg animation'],10)

def action_on_print_event(words, hook_id, ctx_id):
	if myApplet.HookPrintId != hook_id:
		return
	if len(words) < 2:
		return
	print ">>> PRINT :" + words[1]
	if not myApplet.bHasFocus:  # si l'utilisateur n'est pas devant xchat, on le notifie du message.
		if myApplet.config['channel message']:
			if myApplet.config['duration'] == 0:
				coef = 20
			elif myApplet.config['duration'] == 1:
				coef = 10
			else:
				coef = 5
			myApplet.icon.ShowDialog(words[1],max(1,len(words[1])/coef))
		if myApplet.config['msg animation'] != '':
			myApplet.icon.Animate(myApplet.config['msg animation'],2000)
		myApplet.bHasUnread = True
	myApplet.iNbMsg += 1
	myApplet.pMsgList.insert(0,words[1])
	if myApplet.iNbMsg > 100 :
		del myApplet.pMsgList[100]
		myApplet.iNbMsg -= 1
	
def action_on_unload_event():
	print ">>> xchat quits"
	del myApplet.xchat
	myApplet.xchat = None

##########################
### connect to signals ###
##########################
myIcon.connect_to_signal("on_click", action_on_click)  # when the user left-clicks on our icon.
myIcon.connect_to_signal("on_middle_click", action_on_middle_click)  # when the user middle-clicks on our icon.
myIcon.connect_to_signal("on_build_menu", action_on_build_menu)  # when the user right-clicks on our applet (which builds the menu)
myIcon.connect_to_signal("on_menu_select", action_on_menu_select)  # when the user selects an entry of this menu.
myIcon.connect_to_signal("on_scroll", action_on_scroll)  # when the user scroll up or down on our icon.
myIcon.connect_to_signal("on_answer", action_on_answer)  # when the user answer a question.
myIcon.connect_to_signal("on_change_focus", action_on_change_focus)  # when the user (un)focuses the xchat window.
myIcon.connect_to_signal("on_stop_module", action_on_stop)  # when the user deactivate our applet (or the DBus plug-in, or when the Cairo-Dock is stopped).
myIcon.connect_to_signal("on_reload_module", action_on_reload)  # when the user changes something in our config, or when the desklet is resized (with no change in the config).

class Applet:
	def __init__(self,icon):
		self.icon = icon
		self.config = {}
		self.conf_file = os.path.expanduser("~/.config/cairo-dock/current_theme/plug-ins/"+applet_name+"/"+applet_name+".conf")  # path to the conf file of our applet.
		self.xchat = None
		self.HookServerId = 0
		self.HookCmdId = 0
		self.HookPrintId = 0
		self.iSidConnect = 0
		self.iNbTries = 0
		self.iNbMsg = 0
		self.pMsgList = []
		self.iCurrentMsg = 0
		self.bHasUnread = False
		self.bHasFocus = False
	
	def get_config(self):
		keyfile = ConfigParser.RawConfigParser()
		keyfile.read(self.conf_file)
		self.config['channel message'] = keyfile.getboolean('Configuration', 'channel message')
		self.config['msg animation'] = keyfile.get('Configuration', 'msg animation')
		self.config['duration'] = keyfile.getint('Configuration', 'duration')
	
	def load(self):
		self.connect_to_xchat()
		self.icon.ControlAppli("xchat")
		
	def connect_to_xchat(self):
		bus = dbus.SessionBus()
		print ">> connecting to xchat..."
		try:
			proxy = bus.get_object('org.xchat.service', '/org/xchat/Remote')
		except dbus.DBusException:
			print ">>> xchat not available on the bus"
			return
		remote = dbus.Interface(proxy, 'org.xchat.connection')
		path = remote.Connect ("xchat",
			"Cairo-Dock applet",
			"Cairo-Dock applet",
			"1.0")
		print ">>> path :" + path
		proxy = bus.get_object('org.xchat.service', path)
		self.xchat = dbus.Interface(proxy, 'org.xchat.plugin')
		print ">>> connected to " + self.xchat.GetInfo("network") + " (" + self.xchat.GetInfo("server") + ") as " + self.xchat.GetInfo("nick")
		#self.HookServerId = self.xchat.HookServer('PRIVMSG', 0, 0)  # 0 <=> normal priority, 0 <=> let it pass (PRIVMSG, NOTICE, PART, etc)
		self.HookCmdId = self.xchat.HookCommand("cairo-dock", 0, "pouic pouic", 0)  # 0 <=> normal priority, 0 <=> let it pass
		self.HookPrintId = self.xchat.HookPrint("Channel Message", 0, 0)  # 0 <=> normal priority, 0 <=> let it pass
		self.xchat.connect_to_signal("ServerSignal", action_on_server_event)
		self.xchat.connect_to_signal("CommandSignal", action_on_command_catched)
		self.xchat.connect_to_signal("PrintSignal", action_on_print_event)
		self.xchat.connect_to_signal("UnloadSignal", action_on_unload_event)
	
	def disconnect_from_xchat(self):
		if self.xchat == None:
				return
		if self.HookServerId != 0:
			self.xchat.Unhook(self.HookServerId)
			self.HookServerId = 0
		if self.HookCmdId != 0:
			self.xchat.Unhook(self.HookCmdId)
			self.HookCmdId = 0
		if self.HookPrintId != 0:
			self.xchat.Unhook(self.HookPrintId)
			self.HookPrintId = 0
		#self.xchat.Disconnect()  # comment utilise-t-on ca ???
	
	def list_channels(self):
		chans=[]
		channels = self.xchat.ListGet ("channels")
		while self.xchat.ListNext (channels):
			name = self.xchat.ListStr (channels, "channel")
			chans.append(name)
		self.xchat.ListFree (channels)
		return chans
	
	#~ def list_channels_and_users(self):
		#~ channels = self.xchat.ListGet ("channels")
		#~ while self.xchat.ListNext (channels):
			#~ name = self.xchat.ListStr (channels, "channel")
			#~ print "------- " + name + " -------"
			#~ self.xchat.SetContext (xchat.ListInt (channels, "context"))
			#~ users = self.xchat.ListGet ("users")
			#~ while xchat.ListNext (users):
				#~ print "   Nick: " + self.xchat.ListStr (users, "nick")
			#~ self.xchat.ListFree (users)
		#~ self.xchat.ListFree (channels)

############
### main ###
############
if __name__ == '__main__':
	myApplet = Applet(myIcon)
	myApplet.get_config()
	myApplet.load()
	loop = gobject.MainLoop()
	loop.run()
	print ">>> bye"
	sys.exit(0)
